<!DOCTYPE html>
<html lang="en">

<head>
  <style>
    body {
      margin: 0;
      background-color: transparent;
      /* Transparent to show parent StarBackground */
      overflow: hidden;
      font-family: 'Courier New', Courier, monospace;
    }

    #time-display {
      position: absolute;
      bottom: 30px;
      left: 30px;
      /* Default sidebar closed */
      right: auto;
      transition: left 0.3s ease-in-out;
      color: rgba(255, 255, 255, 0.8);
      background: transparent;
      padding: 0;
      border: none;
      font-size: 12px;
      font-family: 'Courier New', Courier, monospace;
      pointer-events: none;
      user-select: none;
      z-index: 100;
    }
  </style>
  <script src="//unpkg.com/three"></script>
  <script src="//unpkg.com/globe.gl"></script>
  <script>
    // Listen for Sidebar State from Parent
    window.addEventListener('message', (event) => {
      if (event.data.type === 'SIDEBAR_STATE') {
        const timeDisplay = document.getElementById('time-display');
        if (timeDisplay) {
          // 256px (Sidebar) + 30px (Gap) = ~290px
          timeDisplay.style.left = event.data.isOpen ? '290px' : '30px';
        }
      }
    });
  </script>
</head>

<body>
  <div id="time-display">Loading Real-Time Data...</div>
  <div id="globeViz"></div>

  <script type="module">
    import { MeshPhongMaterial, ShaderMaterial, Vector2, TextureLoader } from "//unpkg.com/three/build/three.module.js";

    const dayNightShader = {
      vertexShader: `
        varying vec3 vNormal;
        varying vec2 vUv;
        void main() {
          vNormal = normalize(normalMatrix * normal);
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        #define PI 3.141592653589793
        uniform sampler2D dayTexture;
        uniform sampler2D nightTexture;
        uniform vec2 sunPosition;
        uniform vec2 globeRotation;
        varying vec3 vNormal;
        varying vec2 vUv;

        float toRad(in float a) {
          return a * PI / 180.0;
        }

        vec3 Polar2Cartesian(in vec2 c) {
          float theta = toRad(90.0 - c.x); // lng -> phi
          float phi = toRad(90.0 - c.y);   // lat -> theta
          return vec3(
            sin(phi) * cos(theta),
            cos(phi),
            sin(phi) * sin(theta)
          );
        }

        void main() {
          float invLon = toRad(globeRotation.x);
          float invLat = -toRad(globeRotation.y);
          
          // Rotate normal to align with Sun (Static Sun approach relative to object)
          // Or rotate Sun to align with Earth texture
          // Here we rotate the Sun vector by the inverse of the Earth's rotation
          
          mat3 rotX = mat3(
            1, 0, 0,
            0, cos(invLat), -sin(invLat),
            0, sin(invLat), cos(invLat)
          );
          mat3 rotY = mat3(
            cos(invLon), 0, sin(invLon),
            0, 1, 0,
            -sin(invLon), 0, cos(invLon)
          );
          
          vec3 rotatedSunDirection = rotX * rotY * Polar2Cartesian(sunPosition);
          float intensity = dot(normalize(vNormal), normalize(rotatedSunDirection));
          
          vec4 dayColor = texture2D(dayTexture, vUv);
          vec4 nightColor = texture2D(nightTexture, vUv);
          
          // Sharp terminator for realism, smooth for aesthetics
          float blendFactor = smoothstep(-0.15, 0.15, intensity);
          gl_FragColor = mix(nightColor, dayColor, blendFactor);
        }
      `
    };

    // --- REAL TIME SUN POSITION ---
    // Calculates Rough Solar Sub-point (Lat, Lng) for a given Date
    const getRealSunPos = (date) => {
      const pi = Math.PI;

      // 1. Calculate Greenwich Mean Sidereal Time (Rough approximation for Longitude)
      // Sun is at 180 deg at 00:00 UTC? No.
      // At 12:00 UTC, Sun is at 0 deg Longitude (Greenwich).
      // Earth rotates 15 deg per hour.
      // pos = - (UTC_Hour + UTC_Min/60) * 15 + 180 ? 
      // 12:00 -> -12*15 = -180. +180 = 0. Correct.
      // 00:00 -> 0. +180 = 180. Correct.
      // 06:00 -> -90 + 180 = 90E. Sun rises in East. Correct.

      const hours = date.getUTCHours();
      const mins = date.getUTCMinutes();
      const secs = date.getUTCSeconds();
      const decimalHours = hours + mins / 60 + secs / 3600;

      // Sun Longitude: 180 - (decimalHours * 15)
      // Range: [-180, 180]
      let sunLng = 180 - (decimalHours * 15);
      if (sunLng > 180) sunLng -= 360;
      if (sunLng < -180) sunLng += 360;

      // 2. Solar Declination (Latitude)
      // Approx: 23.44 * sin( 360/365 * (days_since_vernal_equinox) )
      // Vernal Equinox ~= March 21 (Day 80)
      const start = new Date(date.getFullYear(), 0, 0);
      const diff = date - start;
      const oneDay = 1000 * 60 * 60 * 24;
      const dayOfYear = Math.floor(diff / oneDay);

      const declination = 23.44 * Math.sin((2 * pi / 365) * (dayOfYear - 81));

      return [sunLng, declination];
    };

    // INIT GLOBE
    // INIT GLOBE
    const world = Globe()
      .globeImageUrl(null) // Ensure no default image
      .backgroundColor('rgba(0,0,0,0)')
      .showAtmosphere(true)
      .atmosphereColor("lightskyblue")
      .atmosphereAltitude(0.15)
      // Label Config
      .labelsData([])
      .labelLat(d => d.lat)
      .labelLng(d => d.lng)
      .labelText(d => d.text)
      .labelSize(1.5)
      .labelDotRadius(0.8)
      .labelColor(() => 'rgba(255, 255, 255, 0.9)')
      .labelResolution(2)
      (document.getElementById('globeViz'));

    // RESIZE HANDLER
    window.addEventListener('resize', () => {
      world.width(window.innerWidth);
      world.height(window.innerHeight);
    });

    // GEO LOCATION LOGIC
    const initLocation = () => {
      fetch('https://ipapi.co/json/')
        .then(res => res.json())
        .then(data => {
          const { latitude, longitude, country_name } = data;
          // Focus User
          world.pointOfView({ lat: latitude, lng: longitude, altitude: 2.0 }, 2000);
          // Add Label
          world.labelsData([{
            lat: latitude,
            lng: longitude,
            text: country_name || "You",
            size: 1.5
          }]);
        })
        .catch(err => {
          console.warn("GeoIP failed, defaulting to India", err);
          // Default: India
          world.pointOfView({ lat: 20.5937, lng: 78.9629, altitude: 2.0 }, 2000);
          world.labelsData([{
            lat: 20.5937,
            lng: 78.9629,
            text: "India",
            size: 1.5
          }]);
        });
    };
    // Trigger Init
    initLocation();

    // MOUSE FORWARDING
    document.addEventListener('mousemove', (e) => {
      if (window.parent) {
        window.parent.postMessage({
          type: 'MOUSE_MOVE_FORWARD',
          clientX: e.clientX,
          clientY: e.clientY
        }, '*');
      }
    });

    // LOAD TEXTURES & APPLY SHADER
    Promise.all([
      new TextureLoader().loadAsync('//cdn.jsdelivr.net/npm/three-globe/example/img/earth-day.jpg'),
      new TextureLoader().loadAsync('//cdn.jsdelivr.net/npm/three-globe/example/img/earth-night.jpg')
    ]).then(([dayTexture, nightTexture]) => {

      const material = new ShaderMaterial({
        uniforms: {
          dayTexture: { value: dayTexture },
          nightTexture: { value: nightTexture },
          sunPosition: { value: new Vector2(0, 0) },
          globeRotation: { value: new Vector2(0, 0) }
        },
        vertexShader: dayNightShader.vertexShader,
        fragmentShader: dayNightShader.fragmentShader
      });

      world.globeMaterial(material);

      // ANIMATION LOOP
      const animate = () => {
        const now = new Date();

        // Update UI
        document.getElementById('time-display').innerText = now.toLocaleString();

        // Update Sun (Real Time)
        const [sunLng, sunLat] = getRealSunPos(now);
        material.uniforms.sunPosition.value.set(sunLng, sunLat);

        // Update Rotation (Sync with Globe controls)
        const pov = world.pointOfView();
        material.uniforms.globeRotation.value.set(pov.lng, pov.lat);

        // Auto-Rotate Earth (Aesthetic Only - doesn't change time)
        world.controls().autoRotate = true;
        world.controls().autoRotateSpeed = 0.05;
        world.controls().update();

        requestAnimationFrame(animate);
      };
      animate();
    });

  </script>
</body>

</html>